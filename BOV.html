<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://kushalvyas.github.io/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="http://kushalvyas.github.io/theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://kushalvyas.github.io/theme/stylesheet/font-awesome.min.css">


    <link href="http://kushalvyas.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="BitsMakeMeCrazy | Kushal Vyas's Blog Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Kushal Vyas" />
<meta name="description" content="Implementing Bag of Visual words for Object Recognition" />
<meta name="keywords" content="ObjectRecognition">
<meta property="og:site_name" content="BitsMakeMeCrazy | Kushal Vyas's Blog"/>
<meta property="og:title" content="Bag of Visual Words Model for Object Classification and Recognition"/>
<meta property="og:description" content="Implementing Bag of Visual words for Object Recognition"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://kushalvyas.github.io/BOV.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-07-13 20:40:00+05:30"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://kushalvyas.github.io/author/kushal-vyas.html">
<meta property="article:section" content="Object Recognition, Classification, CV"/>
<meta property="article:tag" content="ObjectRecognition"/>
<meta property="og:image" content="">
  <title>BitsMakeMeCrazy | Kushal Vyas's Blog &ndash; Bag of Visual Words Model for Object Classification and Recognition</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://kushalvyas.github.io">
        <img src="http://kushalvyas.github.io/theme/img/profile.png" alt="Kushal Vyas" title="Kushal Vyas">
      </a>
      <h1><a href="http://kushalvyas.github.io">Kushal Vyas</a></h1>
      <p>Live your life in binary, for all I know analog is simply complicated</p>
      <nav>
        <ul class="list">
          <li><a href="http://kushalvyas.github.io/pages/about-me.html#about-me">About&nbsp;me</a></li>
          <li><a href="http://kushalvyas.github.io/pages/technical.html#technical">Computer&nbsp;Vision</a></li>
          <li><a href="http://kushalvyas.github.io/pages/dev, technical.html#dev, technical">Dev</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="http://www.github.com/kushalvyas" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-envelope-o" href="mailto:kushalvyaskv@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li>
        <li><a class="sc-twitter" href="https://twitter.com/kushal_kv" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-youtube" href="http://goo.gl/r4nP66" target="_blank"><i class="fa fa-youtube"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://kushalvyas.github.io">Home</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="http://kushalvyas.github.io/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h1 id="BOV">Bag of Visual Words Model for Object Classification and&nbsp;Recognition</h1>
    <p>Posted on Wed 13 July 2016 in <a href="http://kushalvyas.github.io/category/object-recognition-classification-cv.html">Object Recognition, Classification, CV</a></p>
  </header>
  <div>
    <p>Bag of Visual Words is an extention to the <span class="caps">NLP</span> algorithm Bag of Words used for image classification. Other than <span class="caps">CNN</span>, it is quite widely used. I sure want to tell that <span class="caps">BOVW</span> is one of the finest things I&#8217;ve encountered in my vision explorations until&nbsp;now.</p>
<p>So what&#8217;s the difference between Object Detection and Objet Recognition .. !! 
Well, recognition simply involves stating whether an image contains a specific object or no. whereas detection also demands the position of the object inside the image. So say, there is an input image containing a cup, saucer, bottle, etc. The task is to be able to recognize which of the objects are contained in the&nbsp;image.</p>
<p><br></p>
<p><span class="caps">BOV</span> was developed by <a href="" target="_blank">CSurka et. al</a> essentially creates a vocabulary that can best describe the image in terms of extrapolable features. It follows 4 simple&nbsp;steps</p>
<ul>
<li>Determination of Image features of a given&nbsp;label </li>
<li>Construction of visual vocabulary by clustering, followed by frequency&nbsp;analysis</li>
<li>Classification of images based on vocabulary&nbsp;genereated</li>
<li>Obtain most optimum class for query&nbsp;image </li>
</ul>
<p><br></p>
<p>To implement this, we shall be using : Opencv (3.x), sklearn (0.17), caltech101 dataset( trimmed&nbsp;version)</p>
<p>Lets first understand what a feature is. One can say that a feauture is any discernable, and a significant point/group of points in an image. What to select as a feature depends on the application such as corner points, edges, blobs, <span class="caps">DOG</span> , etc. And to ease out our troubles, <a href="http://www.cs.ubc.ca/~lowe/keypoints/" target="_blank">David Lowe</a> developed <a href="http://www.cs.ubc.ca/~lowe/keypoints/" target="_blank"><span class="caps">SIFT</span></a> : Scale Invariant Feature Transform. <span class="caps">SIFT</span> is extensively used today. We will be using <span class="caps">SIFT</span> as well. Please note, that algorithms such as <span class="caps">SIFT</span>, <span class="caps">SURF</span> which are patented are not available in the master version of Opencv-Itseez. To be able to use it, either install opencv_contrib or <span class="caps">VLFEAT</span> (You may want to check out my <a href="http://kushalvyas.github.io/setup_env.html">previous post on environment settings </a>).</p>
<p>Lets begin with a few introductory concepts required Bag of words. We shall cover 4 parts (so keep scrolling&nbsp;!)</p>
<ul>
<li>Clustering</li>
<li>Bag of Visual Words&nbsp;Model</li>
<li>Generating&nbsp;Vocabulary</li>
<li>Training and&nbsp;testing</li>
</ul>
<p><br></br></p>
<p><strong>Clustering</strong> : Lets say there is a bunch of Wrigleys Skittles. And someone is to tell you to group them according to their color. It&#8217;s quite simple .. aint it! Simply seperate all red, blue, green, etc in different parts of the room. Here, we differentiated and seperated them on basis of <strong>color only</strong>.<br />
So moving on to a more complex situation that would give a much profound meaning to clustering. Suppose there is a room full of utilities, be it accesories, clothing, utensils, electronics, etc. Now, if someone is told to seperate out into well formed groups of similar items, one would essentially be performing&nbsp;clustering. </p>
<p>So yes, clustering can be said as the grouping a set of objects in such a way that objects in the same group are much similar, than to those in other&nbsp;groups/sets</p>
<p>Moving on, lets&#8217; decide as to how we perform clustering. The selection of clustering algorithm depends more on what kind of similarity model is to be chosen. There are cases wherein, the plain&#8217;ol clustering impression that everyone so simply elucidates may not be the right choice. For example, there exists various models, such as centroid oriented - Kmeans, or Distribution based models - that involve clustering for statistical data; such places require Density based clustering (<span class="caps">DBSCAN</span>) ,&nbsp;etc. </p>
<p>Beginning with <strong>KMeans clustering</strong>. Suppose there are X objects, that are to be divided into K clusters. The input can be a set of features, <span class="math">\(X = \{ x_1, x_2, ..., x_n \}\)</span>. The goal is basically to minimize the distance between each point in the scatter cloud and the assigned&nbsp;centroids. </p>
<div class="math">$$ {\underset {\mathbf {S} }{\operatorname {arg\,min} }}\sum _{i=1}^{k}\sum _{\mathbf {x} \in S_{i}}\left\|\mathbf {x} -{\boldsymbol {\mu }}_{i}\right\|^{2}
 $$</div>
<p>where <span class="math">\(\mu\)</span>   is mean of points for each <span class="math">\(S_i\)</span>(cluster) and <span class="math">\(S\)</span> denotes set of points partitioned into clusters of <span class="math">\(\{ S_1, S_2, ... S_i&nbsp;\}\)</span> </p>
<p>Hence it can be said that for each cluster centroid, there exists a group of point around it, known as the&nbsp;center. </p>
<ul>
<li>
<p>We first define an initial random solution. This initial solution can be called as the cluster centroids. They need to be randomly placed within the bounds of data , and not so callously&nbsp;random. </p>
</li>
<li>
<p>Second comes the <strong>Assignment Step</strong>. What happens here, is that KMeans iterates over each of the input feature / datapoint and decides which is the closest cluster centroid w.r.t itself. Once the closest centroid is established, it is then alloted to that particular&nbsp;centroid.</p>
</li>
<li>
<p>Next is the <strong>Average <span class="amp">&amp;</span> Update Step</strong>. Once we are able to perform the first, most crude clustering, we shall relocate the cluster centroids. The newly computed cluster centroids can be said to be the aggregate of all members of that particular cluster. Hence the centroid moves more inwards for a tightly alligned distribution and more outwards&nbsp;otherwise.</p>
</li>
<li>
<p>Once the avergaing step is accomplished, and the new clusters are computed, the same process is repeated over and over again. Untill &#8230;&nbsp;!!! </p>
</li>
<li>
<p>The ideal condition for stoppage is when there is no change in position of the newly computed cluster centroid with respect to its previous position. This can be further interpreted as that the distance of every datapoint inside its cluster will be minimum w.r.t its mean i.e its centroid. However, there can be a minimum threshold value to stop the clustering process from going on and&nbsp;on.</p>
</li>
</ul>
<p>Okay, below is a snippet showing how to use KMeans clustering algorithm as provided in <a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html">scikit</a>.</p>
<div class="gist">
    <script src='https://gist.github.com/590b7e1adad10656793cfb78f041193a.js'></script>
    <noscript>
        <pre><code>
n_samples = 1000
n_features = 5;
n_clusters = 3;

# aint this sweet 
X, y = make_blobs(n_samples, n_features) 
# X => array of shape [nsamples,nfeatures] ;;; y => array of shape[nsamples]

# X : generated samples, y : integer labels for cluster membership of each sample
# performing KMeans clustering

ret =  KMeans(n_clusters = n_clusters).fit_predict(X)</code></pre>
    </noscript>
</div>
<!-- output -->

<p><img alt="clusteroutput" src="http://kushalvyas.github.io/images/clusterplot1.png" /></p>
<p><center>Here&#8217;s a sample output for clustering using 3 clusters on a set of 1000 samples.</center></p>
<p><strong>Why are we using Clusterng &#8230; Why Kmeans &#8230;: </strong>
KMeans performs clustering. It is one of the widely used algorithms when it comes to unsupervised learning. Bag of visual words uses a training regimen that involves, firstly, to partition similar features that are extrapolated from the training set of images. To make it more easily understandable, think of it this way. Every image has certain discernable features, patterns with which humans decide as to what the object perceived is. When you see a image of &#8230; umm. let&#8217;s say a motorbike -  significant features are being extrapolated. This features together help in deciding whether what is being seen is actually a motorbike. The collection as well as frequency of particular features is what helps in estimating what object does the image&nbsp;contain,</p>
<p><u>Some Prerequisites :</u>  </p>
<ul>
<li>
<p>First of all, you need a training set. If you&#8217;re using a personal computer, I&#8217;d recommend to use a truncated version of any publically available image datasets (if you&#8217;re worried about your <span class="caps">PC</span> taking up too much time during training) or perhaps train using a minimally bounded set of features. I&#8217;d recommend using <a href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">Caltech101</a>. Also check out Caltech256, <span class="caps">CIFAR10</span> datasets. They&#8217;re good !! As in real&nbsp;good. </p>
</li>
<li>
<p>Secondly please set up either <span class="caps">LIBSVM</span> , <span class="caps">SKLEARN</span>,  <span class="caps">VLFEAT</span> ( for enhanced vision algos&#8230; like sift) Library, or Any python machine learning toolkit that will provide basic <span class="caps">SVM</span> , Kmeans functionaliy. You can visit my previous post on <a href="http://kushalvyas.github.io/setup_env.html">setting up environments</a>.</p>
</li>
<li>
<p>Third, please maintain a descent project directory structure. Well documented and well assembled as to where input , output and logs will be stored. This will help a lot for further projects and especially when it comes to making your code&nbsp;modular.</p>
</li>
</ul>
<p>So lets&#8217;&nbsp;proceed. </p>
<h1><strong>Bag of Visual&nbsp;Words</strong></h1>
<p>This is a supervised learning model. There will be a training set and a testing set.
You can find my implementation on <a href="https://github.com/kushalvyas/Bag-of-Visual-Words-Python" target="_blank">Github</a>. </p>
<ol>
<li>
<p>Split the downloaded dataset into training and testing. You can use the 70-30 ratio or 80-20. But keep in mind, if the training data is not good , there <span class="caps">WILL</span> be discrepencies in the&nbsp;output.</p>
</li>
<li>
<p><span class="caps">BOVW</span> is an example of supervised learning. It&#8217;s always better to keep a mapping of which images belong to what classification label ( a label can be defined as a key/value for identifying to what class/category does the object&nbsp;belongs).</p>
</li>
<li>
<p>Extract features from the training image sets. One can use opencv_contrib/ vl feat  for <a href="{filename}/articles/features.md">Feature Extration</a>(<span class="caps">SIFT</span>, <span class="caps">SURF</span> more popularly). This essentially converts the image into a feature&nbsp;vector. </p>
</li>
<li>
<p>The final step is codebook generation. A codebook can be thought of as a dictionary that registers corresponding mappings between features and their definition in the object. We need to define set of words (essentially the features marked by words) that provides an analogous relation of an object ( being trained) w.r.t. a set of&nbsp;features. </p>
</li>
</ol>
<!-- 
[gist:id=4e5044cc533096f45323de43b85000be]
 -->

<p>Project Architecture&nbsp;: </p>
<div class="highlight"><pre><span class="o">-</span> <span class="n">root</span> <span class="nb">dir</span><span class="o">/</span>
    <span class="o">|-</span> <span class="n">images</span><span class="o">/</span>
            <span class="o">|-</span> <span class="n">test</span> <span class="o">/</span>
                <span class="o">|-</span> <span class="n">obj1</span><span class="o">/</span>
                <span class="o">|-</span> <span class="n">obj2</span><span class="o">/</span>

            <span class="o">|-</span> <span class="n">train</span> <span class="o">/</span>
                <span class="o">|-</span> <span class="n">obj1</span><span class="o">/</span>
                <span class="o">|-</span> <span class="n">obj2</span><span class="o">/</span>

    <span class="o">|-</span> <span class="n">helpers</span><span class="o">.</span><span class="n">py</span>
    <span class="o">|-</span> <span class="n">Bag</span><span class="o">.</span><span class="n">py</span>


<span class="p">:</span><span class="o">~</span><span class="err">$</span> <span class="n">python</span> <span class="n">Bag</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">train_set</span> <span class="n">images</span><span class="o">/</span><span class="n">train</span><span class="o">/</span> <span class="o">--</span><span class="n">test_set</span> <span class="n">images</span><span class="o">/</span><span class="n">test</span><span class="o">/</span>
</pre></div>


<p><span class="math">\(images\)</span> directory contains testing and training images. Provide the path to test and train images to <span class="math">\(Bag.py\)</span>&nbsp;file.</p>
<p>We shall go through each module, step by step. <code>Bag.py</code> contains the main. We have the methods <code>trainModel</code> and <code>testModel</code>. <code>Heplers.py</code> contains various helper functionalities. It contains Imagehelpers, FileHelper, BOVhelpers. Imagehelpers contains colorscheme conversion, feature detection. FileHelper returns a dictionary of each object-name with a corresponding list of all images. It also returns total image count. (required&nbsp;later)</p>
<p>FileHelper will return the training set. It returns a dictionary with <code>key = object_name</code> and <code>value = list of images</code> and total number of&nbsp;images.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FileHelper</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    - returns  a dictionary of all files </span>
<span class="sd">    having key =&gt; value as  objectname =&gt; image path</span>
<span class="sd">    - returns total number of files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imlist</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s">&quot;*&quot;</span><span class="p">):</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">each</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&quot; #### Reading image category &quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="s">&quot; ##### &quot;</span>
        <span class="n">imlist</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">imagefile</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="n">word</span><span class="o">+</span><span class="s">&quot;/*&quot;</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;Reading file &quot;</span><span class="p">,</span> <span class="n">imagefile</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">imagefile</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">imlist</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">imlist</span><span class="p">,</span> <span class="n">count</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>ImageHelpers&#8217;s primary function is to provide with <span class="caps">SIFT</span> features present in an image. We require these image features to develop our vocabulary.(I&#8217;ll explain what it means in the coming parts ..&nbsp;). </p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ImageHelpers</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sift_object</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">xfeatures2d</span><span class="o">.</span><span class="n">SIFT_create</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">gray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gray</span>

    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sift_object</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p><br></br></p>
<p>I will reiterate the algorithm once again, and now step by step. With the input image list, firstly compute features. You&#8217;ll need objects of all helper classes. So please initialize them in your main module. Having detected and computed <span class="caps">SIFT</span> features, we need to process a&nbsp;vocabulary.</p>
<h2><strong>How to develop visual vocabulary&nbsp;?</strong></h2>
<p><span class="dquo">&#8220;</span>A picture is worth a thousand words &#8230;&nbsp;&#8220;</p>
<p>Suppose I say, there is an image of a shoe. Humans tend to describe using normal english language words. A person will probably descibe a shoe as a shoe! A bit elaborated version may be , something having laces and small netted structures. Go a bit further, and it&#8217;ll seem to have small holes/circles, a few curved lines, a bunch of very striking corner points, a few patches having high contrast. Now you&#8217;re speaking in terms of a vision. One can dumb down the idea of descriptors / features in an image as striking/significant portions of the image that help describe it. Every image contains multiple features i.e. if we were to mathematically express an image in terms of features, we would say that an Image is a collection of features , where every feature may have a certain frequency of&nbsp;occurence.</p>
<p>If it is so, how can we differentiate w.r.t features. !!! The answer comes from a much natural origin. Suppose a human was asked to differentiate between a shoe and a lipstick :P . He/she would start describing each of the aforementioned item. Shoe would have small circular pathes, long laces, much curved portions, etc. On the other hand, a lipstick is quite cylindrical and has a top buldge. So i can say , 
<br></br>
<strong> for a set of given features, there exists a weighted combination of features that describe an image individually </strong>
<br></br>
and that <br></br>
<strong>Every feature present in an image, can be used as means for describing the same image</strong>
<br></br></p>
<p>From the above two statements, we define what a visual word is. Simply any thing that can be used to describe an image , we consider them as a visual word. Thus, our image becomes a combination of visual words (that are essentially features). And to make it more mathematical, we define this structure as a histogram. Essentially, histogram is just a measure of frequency occurence of a particular item, here in our case, we will be describing each image as a histogram of features. How many features out of the total vocabulary are required to make sense of what the computer is looking at&nbsp;. </p>
<h3><strong>Linking vocabulary and clustering </strong>:</h3>
<p>Using <span class="caps">SIFT</span>, we detect and compute features inside each image. <span class="caps">SIFT</span> returns us a <span class="math">\(m \times 128\)</span> dimension array, where m is the number of features extrapolated. Similarly, for multiple images, say 1000 images, we shall&nbsp;obtain </p>
<div class="math">$$ \begin{bmatrix}
features_0\\ 
features_1\\ 
    ....      \\ 
    ....       \\
    ....       \\
features_{n}\\
\end{bmatrix}
$$</div>
<div class="math">$$ where \  features_i \ \ is \ \ a  \ \ array \  of  \ \ dimension \ \  m \times 128 $$</div>
<p>We now have a full stacked up list of what visual words are being used for every image. The next task is to group similar features. Think of it as synonyms &#8230;. Similar features can provide an approximate estimate as to what the image is, just as synonyms tend to express upon the gist of a sentence. Therefore when the machine is trained over several images, similar features that are able to describe similar portions of the image are grouped together to develop a vast vocabulary base. Each of these group collectively represent the a word and all groups in totality yields us the complete vocabulary generated from the training data. Hence there is a screaming need for clustering in the said&nbsp;process.</p>
<p>If we were to allot a definition to any of the similar words, we can simply refer them by their cluster&nbsp;number.</p>
<p><center>
<img alt="image" size:small="size:small" src="http://kushalvyas.github.io/images/grid.png" />
<!-- <img alt="image" src="http://kushalvyas.github.io/images/vocab.png" /> </center> --></p>
<p>A more illustrative visualization of the histogram can be observed in the adjacent&nbsp;figure.</p>
<p><img alt="image" size:small="size:small" src="http://kushalvyas.github.io/images/vocab_unnormalized.png" /></p>
<p>The above image shows how a collective vocabulary will look like. Encomprising of the total number of each type of feature/word present in the training set in&nbsp;totality.</p>
<p></center></p>
<p>Here&#8217;s some implementation snippet as to how one would implement&nbsp;this</p>
<div class="gist">
    <script src='https://gist.github.com/ad29abbc3b68b1cf530490bbe4eaec73.js'></script>
    <noscript>
        <pre><code>def developVocabulary(self,n_images, descriptor_list, kmeans_ret = None):
		
		"""
		Each cluster denotes a particular visual word 
		Every image can be represeted as a combination of multiple 
		visual words. The best method is to generate a sparse histogram
		that contains the frequency of occurence of each visual word 

		Thus the vocabulary comprises of a set of histograms of encompassing
		all descriptions for all images

		"""

		self.mega_histogram = np.array([np.zeros(self.n_clusters) for i in range(n_images)])
		old_count = 0
		for i in range(n_images):
			l = len(descriptor_list[i])
			for j in range(l):
				if kmeans_ret is None:
					idx = self.kmeans_ret[old_count+j]
				else:
					idx = kmeans_ret[old_count+j]
				self.mega_histogram[i][idx] += 1
			old_count += l
		print "Vocabulary Histogram Generated"
</code></pre>
    </noscript>
</div>
<p>As seen, the input is n_images i.e. the total number of images and descriptor_list, that contains the feature descriptor array ( one discussed above, the full stacked up list of features). Our histogram is therefore of the size <span class="math">\(n\_images \times n\_clusters\)</span> thereby defining each image in terms of generated vocabulary. During the definition phase, we need to locate the cluster that contains the features i.e the cluster number whose cluster centroid is nearest to the location of the current&nbsp;feature. </p>
<p>This completes the most important part of the vocabulary generation. Now time to train the&nbsp;machine.</p>
<h3><u> Training the machine to understand the images using <span class="caps">SVM</span>   </u></h3>
<p>Our <span class="math">\(mega\_histrogram\)</span> is basically an array of size <span class="math">\(n\_samples, n\_significantFeatures\)</span>. Meaning, the number of rows, that are defined as the <span class="math">\(n\_imagses\)</span> in the above snippet, are nothing but samples we need to train. Each row contains a distribution/combination of visual words used to describe the image. All we need is a multiclass classifier to distinguish between similar images and to define classes for the&nbsp;same.</p>
<p>for classification purposes, I&#8217;d recommend to use sklearn. Its by far the most easily adaptable <span class="caps">API</span> i&#8217;ve used. And goes very well with numpy&nbsp;datastructures. </p>
<p>Just so you know, Coding up an <span class="caps">SVM</span> on your own is a herculean task, hence we follow a 1-2-3 methodology as projected by <span class="caps">SKLEARN</span>.</p>
<div class="highlight"><pre><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span> <span class="c"># make classifier object</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span> <span class="c"># train the model</span>
<span class="p">[</span><span class="n">classes</span><span class="p">]</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span> <span class="c">#returns a list of prediction for each test_data</span>
</pre></div>


<p>That&#8217;s it !! Once trained, the model is ready for testing&nbsp;!! </p>
<h3>Implementation&nbsp;Details</h3>
<p>Please maintain the aforementioned project dir structure and follow naming conventions. You may want to read the repositories readme for further details. Here&#8217;s what predictions I obtained on testing and training the model against a trimmed version of Caltech101&nbsp;dataset. </p>
<p><center></p>
<p>There are a few snaps of outputs when the model was tested on the limited version of the dataset&nbsp;.</p>
<p><img alt="im1" src="http://kushalvyas.github.io/images/ac1.png" />
<img alt="im2" src="http://kushalvyas.github.io/images/bk1.png" />
<img alt="im3" src="http://kushalvyas.github.io/images/bk2.png" />
<img alt="im4" src="http://kushalvyas.github.io/images/dollar1.png" />
<img alt="im5" src="http://kushalvyas.github.io/images/sbb3.png" /></p>
<p></center></p>
<h3>Checking for&nbsp;Accuracy</h3>
<p>Accuracy measure is one of the most important steps in <span class="caps">ML</span> algorithms .A Confusion matrix is basically how many test cases were correctly classified. Hence, a confusion matrix is used to determine the accuracy of classification. On having tried it on the limited dataset, below is the <span class="caps">CF</span>. </p>
<p><center>
    <img alt="imc" src="http://kushalvyas.github.io/images/normalized_7.png" />
</center></p>
<p>So now you know how to write your own Image Classifiers and Recognizers&#8230; !! Hurrayy !! There are tremendous application when it comes to intelligence and computer vision. Especially in this field. If you wanna check for accuracy measures in classification, be sure to implement a <a href="">Confusion Matrix</a> .Meanwhile, use the <a href="http://kushalvyas.github.io/BOV.html">Bag of Visual Words</a> and create some cool&nbsp;stuff</p>
<p><strong> Check out the <a href="https://github.com/kushalvyas/Bag-of-Visual-Words-Python">Code</a> on <a href="https://www.github.com/kushalvyas/">Github</a></strong></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://kushalvyas.github.io/tag/objectrecognition.html">ObjectRecognition</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'bitsmakemecrazy';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
        <p>&copy; Kushal Vyas </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75632170-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->



<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Bag of Visual Words Model for Object Classification and Recognition",
  "headline": "Bag of Visual Words Model for Object Classification and Recognition",
  "datePublished": "2016-07-13 20:40:00+05:30",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Kushal Vyas",
    "url": "http://kushalvyas.github.io/author/kushal-vyas.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "http://kushalvyas.github.io/BOV.html",
  "description": "Implementing Bag of Visual words for Object Recognition"
}
</script></body>
</html>